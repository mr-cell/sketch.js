// Generated by CoffeeScript 1.9.2
(function() {
  var slice = [].slice;

  (function($) {
    var Sketch;
    $.fn.sketch = function() {
      var args, key, sketch;
      key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.length > 1) {
        $.error('Sketch.js can only be called on one element at a time.');
      }
      sketch = this.data('sketch');
      if (typeof key === 'string' && sketch) {
        if (sketch[key]) {
          if (typeof sketch[key] === 'function') {
            return sketch[key].apply(sketch, args);
          } else if (args.length === 0) {
            return sketch[key];
          } else if (args.length === 1) {
            return sketch[key] = args[0];
          }
        } else {
          return $.error('Sketch.js did not recognize the given command.');
        }
      } else if (sketch) {
        return sketch;
      } else {
        this.data('sketch', new Sketch(this.get(0), key));
        return this;
      }
    };
    Sketch = (function() {
      function Sketch(el, opts) {
        this.el = el;
        this.canvas = $(el);
        this.context = el.getContext('2d');
        this.options = $.extend({
          toolLinks: true,
          defaultTool: 'marker',
          defaultColor: '#000000',
          defaultSize: 5,
          defaultStyle: 'solid'
        }, opts);
        this.painting = false;
        this.color = this.options.defaultColor;
        this.size = this.options.defaultSize;
        this.tool = this.options.defaultTool;
        this.style = this.options.defaultStyle;
        this.text = '';
        this.actions = [];
        this.undoneActions = [];
        this.action = [];
        this.lineAction = [];
        this.linePainting = false;
        this.circleAction = [];
        this.circlePainting = false;
        this.rectAction = [];
        this.rectPainting = false;
        this.canvas.bind('click mousedown mouseup mousemove mouseleave mouseout touchstart touchmove touchend touchcancel', this.onEvent);
        if (this.options.toolLinks) {
          $('body').delegate("a[href=\"#" + (this.canvas.attr('id')) + "\"]", 'click', function(e) {
            var $canvas, $this, i, key, len, ref, sketch;
            $this = $(this);
            $canvas = $($this.attr('href'));
            sketch = $canvas.data('sketch');
            ref = ['color', 'size', 'tool', 'style'];
            for (i = 0, len = ref.length; i < len; i++) {
              key = ref[i];
              if ($this.attr("data-" + key)) {
                sketch.set(key, $(this).attr("data-" + key));
              }
            }
            if ($(this).attr('data-download')) {
              sketch.download($(this).attr('data-download'));
            }
            return false;
          });
        }
      }

      Sketch.prototype.download = function(format) {
        var mime;
        format || (format = "png");
        if (format === "jpg") {
          format = "jpeg";
        }
        mime = "image/" + format;
        return window.open(this.el.toDataURL(mime));
      };

      Sketch.prototype.set = function(key, value) {
        this[key] = value;
        return this.canvas.trigger("sketch.change" + key, value);
      };

      Sketch.prototype.startPainting = function() {
        this.painting = true;
        return this.action = {
          tool: this.tool,
          color: this.color,
          size: parseFloat(this.size),
          style: this.style,
          events: []
        };
      };

      Sketch.prototype.stopPainting = function() {
        if (this.action) {
          this.actions.push(this.action);
        }
        this.painting = false;
        this.action = null;
        return this.redraw();
      };

      Sketch.prototype.startLine = function() {
        this.linePainting = true;
        return this.lineAction = {
          tool: this.tool,
          color: this.color,
          size: parseFloat(this.size),
          style: this.style,
          events: []
        };
      };

      Sketch.prototype.stopLine = function() {
        if (this.lineAction) {
          this.actions.push(this.lineAction);
        }
        this.linePainting = false;
        this.lineAction = null;
        return this.redraw();
      };

      Sketch.prototype.startCircle = function() {
        this.circlePainting = true;
        return this.circleAction = {
          tool: this.tool,
          color: this.color,
          size: parseFloat(this.size),
          style: this.style,
          events: []
        };
      };

      Sketch.prototype.stopCircle = function() {
        if (this.circleAction) {
          this.actions.push(this.circleAction);
        }
        this.circlePainting = false;
        this.circleAction = null;
        return this.redraw();
      };

      Sketch.prototype.startRect = function() {
        this.rectPainting = true;
        return this.rectAction = {
          tool: this.tool,
          color: this.color,
          size: parseFloat(this.size),
          style: this.style,
          events: []
        };
      };

      Sketch.prototype.stopRect = function() {
        if (this.rectAction) {
          this.actions.push(this.rectAction);
        }
        this.rectPainting = false;
        this.rectAction = null;
        return this.redraw();
      };

      Sketch.prototype.pointDistance = function(point1, point2) {
        var xs, ys;
        xs = point2.x - point1.x;
        ys = point2.y - point1.y;
        return Math.sqrt((xs * xs) + (ys * y2));
      };

      Sketch.prototype.calculateLineStyle = function(style, size) {
        var result;
        result = [];
        if (style === 'dashed') {
          result[0] = 3 * size;
          result[1] = 3 * size;
        } else if (style === 'dotted') {
          result[0] = 1;
          result[1] = 2 * size;
        }
        return result;
      };

      Sketch.prototype.drawArrowAtBeginningOfLine = function(startX, startY, endX, endY, arrowSize) {
        var angleLeft, angleRight;
        angleRight = 1 - Math.atan2(endX - startX, endY - startY);
        angleLeft = 1 - Math.atan2(endY - startY, endX - startX);
        this.context.moveTo(startX, startY);
        this.context.lineTo(endX - arrowSize * Math.cos(angleRight), endY - arrowSize * Math.sin(angleRight));
        this.context.moveTo(endX, endY);
        return this.context.lineTo(endX - arrowSize * Math.sin(angleLeft), endY - arrowSize * Math.cos(angleLeft));
      };

      Sketch.prototype.drawArrowAtEndOfLine = function(startX, startY, endX, endY, arrowSize) {
        var angleLeft, angleRight;
        angleRight = 1 - Math.atan2(endX - startX, endY - startY);
        angleLeft = 1 - Math.atan2(endY - startY, endX - startX);
        this.context.moveTo(endX, endY);
        this.context.lineTo(endX - arrowSize * Math.cos(angleRight), endY - arrowSize * Math.sin(angleRight));
        this.context.moveTo(endX, endY);
        return this.context.lineTo(endX - arrowSize * Math.sin(angleLeft), endY - arrowSize * Math.cos(angleLeft));
      };

      Sketch.prototype.onEvent = function(e) {
        if (e.originalEvent && e.originalEvent.targetTouches) {
          e.pageX = e.originalEvent.targetTouches[0].pageX;
          e.pageY = e.originalEvent.targetTouches[0].pageY;
        }
        $.sketch.tools[$(this).data('sketch').tool].onEvent.call($(this).data('sketch'), e);
        e.preventDefault();
        return false;
      };

      Sketch.prototype.redraw = function() {
        var sketch;
        this.context = this.el.getContext('2d');
        this.context.clearRect(0, 0, this.el.width, this.el.height);
        sketch = this;
        $.each(this.actions, function() {
          if (this.tool) {
            return $.sketch.tools[this.tool].draw.call(sketch, this);
          }
        });
        if (this.painting && this.action) {
          return $.sketch.tools[this.action.tool].draw.call(sketch, this.action);
        }
        if (this.linePainting && this.lineAction) {
          return $.sketch.tools[this.lineAction.tool].draw.call(sketch, this.lineAction);
        }
        if (this.circlePainting && this.circleAction) {
          return $.sketch.tools[this.circleAction.tool].draw.call(sketch, this.circleAction);
        }
        if (this.rectPainting && rectAction) {
          return $.sketch.tools[this.rectAction.tool].draw.call(sketch, this.rectAction);
        }
      };

      return Sketch;

    })();
    $.sketch = {
      tools: {}
    };
    $.sketch.tools.marker = {
      onEvent: function(e) {
        switch (e.type) {
          case 'mousedown':
          case 'touchstart':
            this.startPainting();
            break;
          case 'mouseup':
          case 'mouseout':
          case 'mouseleave':
          case 'touchend':
          case 'touchcancel':
            this.stopPainting();
        }
        if (this.painting) {
          this.action.events.push({
            x: e.pageX - this.canvas.offset().left,
            y: e.pageY - this.canvas.offset().top,
            event: e.type
          });
          return this.redraw();
        }
      },
      draw: function(action) {
        var event, i, len, lineStyle, previous, ref;
        this.context.lineJoin = "round";
        this.context.lineCap = "round";
        lineStyle = this.calculateLineStyle(action.style, action.size);
        this.context.beginPath();
        this.context.setLineDash(lineStyle);
        this.context.moveTo(action.events[0].x, action.events[0].y);
        ref = action.events;
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          this.context.lineTo(event.x, event.y);
          previous = event;
        }
        this.context.strokeStyle = action.color;
        this.context.lineWidth = action.size;
        return this.context.stroke();
      }
    };
    $.sketch.tools.line = {
      onEvent: function(e) {
        switch (e.type) {
          case 'mousedown':
          case 'touchstart':
            this.startLine();
            break;
          case 'mouseup':
          case 'mouseout':
          case 'mouseleave':
          case 'touchend':
          case 'touchcancel':
            this.stopLine();
        }
        if (this.linePainting) {
          if (this.lineAction.events.length > 1) {
            this.lineAction.events.pop();
          }
          this.lineAction.events.push({
            x: e.pageX - this.canvas.offset().left,
            y: e.pageY - this.canvas.offset().top,
            event: e.type
          });
          return this.redraw();
        }
      },
      draw: function(action) {
        var event, i, len, lineStyle, previous, ref;
        this.context.lineJoin = 'round';
        this.context.lineCap = 'round';
        lineStyle = this.calculateLineStyle(action.style, action.size);
        this.context.beginPath();
        this.context.setLineDash(lineStyle);
        this.context.moveTo(action.events[0].x, action.events[0].y);
        ref = action.events;
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          if (action.drawStartAction) {
            this.drawArrowAtBeginningOfLine(action.events[0].x, action.events[0].y(event.x, event.y, action.size * 4));
          }
          this.context.lineTo(event.x, event.y);
          this.drawArrowAtEndOfLine(action.events[0].x, action.events[0].y, event.x, event.y, action.size * 4)(action.drawEndArrow ? previous = event : void 0);
        }
        this.context.strokeStyle = action.color;
        this.context.lineWidth = action.size;
        return this.context.stroke();
      }
    };
    $.sketch.tools.arrow_line = {
      onEvent: function(e) {
        return $.sketch.tools.line.onEvent.call(this, each);
      },
      draw: function(action) {
        action.drawEndArrow = true;
        return $.sketch.tools.line.draw.call(this, action);
      }
    };
    $.sketch.tools.double_arrow_line = {
      onEvent: function(e) {
        return $.sketch.tools.line.onEvent.call(this, each);
      },
      draw: function(action) {
        action.drawStartArrow = true;
        action.drawEndArrow = true;
        return $.sketch.tools.line.draw.call(this, action);
      }
    };
    $.sketch.tools.circle = {
      onEvent: function(e) {
        switch (e.type) {
          case 'mousedown':
          case 'touchstart':
            this.startCircle();
            break;
          case 'mouseup':
          case 'mouseout':
          case 'mouseleave':
          case 'touchend':
          case 'touchcancel':
            this.stopCircle();
        }
        if (this.circlePainting) {
          if (this.circleAction.events.length > 1) {
            this.circleAction.events.pop();
          }
          this.circleAction.events.push({
            x: e.pageX - this.canvas.offset().left,
            y: e.pageY - this.canvas.offset().top,
            event: e.type
          });
          return this.redraw();
        }
      },
      draw: function(action) {
        var event, i, len, lineStyle, previous, radius, ref;
        this.context.lineJoin = 'round';
        this.context.lineCap = 'round';
        lineStyle = this.calculateLineStyle(action.style, action.size);
        this.context.beginPath();
        this.context.setLineDash(lineStyle);
        ref = action.events;
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          radius = this.pointDistance({
            x: action.events[0].x,
            y: action.events[0].y
          }, {
            x: event.x,
            y: event.y
          });
          this.context.arc(action.events[0].x, action.events[0].y, radius, 0, 2 * Math.PI);
          previous = event;
        }
        this.context.strokeStyle = action.color;
        this.context.lineWidth = action.size;
        return this.context.stroke();
      }
    };
    $.sketch.tools.rectangle = {
      onEvent: function(e) {
        switch (e.type) {
          case 'mousedown':
          case 'touchstart':
            this.startRect();
            break;
          case 'mouseup':
          case 'mouseout':
          case 'mouseleave':
          case 'touchend':
          case 'touchcancel':
            this.stopRect();
        }
        if (this.rectPainting) {
          if (this.rectAction.events.length > 1) {
            this.rectAction.events.pop();
          }
          this.rectAction.events.push({
            x: e.pageX - this.canvas.offset().left,
            y: e.pageY - this.canvas.offset().top,
            event: e.type
          });
          return this.redraw();
        }
      },
      draw: function(action) {
        var event, height, i, len, lineStyle, previous, ref, width;
        this.context.lineJoin = 'round';
        this.context.lineCap = 'round';
        lineStyle = this.calculateLineStyle(action.style, action.size);
        this.context.beginPath();
        this.context.setLineDash(lineStyle);
        ref = action.events;
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          width = event.x - action.events[0].x;
          height = event.y - action.events[0].y;
          this.context.rect(action.events[0].x, action.events[0].y, width, height);
          previous = event;
        }
        this.context.strokeStyle = action.color;
        this.context.lineWidth = action.size;
        return this.context.stroke();
      }
    };
    this.sketch.tools.text = {
      onEvent: function(e) {
        switch (e.type) {
          case 'mouseup':
          case 'touchend':
            this.action = {
              tool: this.tool,
              color: this.color,
              text: this.text,
              size: parseFloat(this.size),
              events: []
            };
            this.action.events.push({
              x: e.pageX - this.canvas.offset().left,
              y: e.pageY - this.canvas.offset().top,
              event: e.type
            });
            this.actions.push(this.action);
            this.action = null;
        }
        return this.redraw();
      },
      draw: function(action) {
        var event, i, len, previous, ref, results;
        this.context.font = '20px SansSerif';
        this.context.fillStyle = action.color;
        ref = action.events;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          this.context.fillText(action.text, event.x, event.y);
          results.push(previous = event);
        }
        return results;
      }
    };
    $.sketch.tools.undo = {
      onEvent: function(e) {
        var lastAction;
        switch (e.type) {
          case 'mouseup':
          case 'touchend':
            lastAction = this.actions.pop();
            if (lastAction) {
              this.undoneActions.push(lastAction);
            }
        }
        return this.redraw();
      },
      draw: function(action) {}
    };
    $.sketch.tools.redo = {
      onEvent: function(e) {
        var lastAction;
        switch (e.type) {
          case 'mouseup':
          case 'touchend':
            lastAction = this.undoneActions.pop();
            if (lastAction) {
              actions.push(lastAction);
            }
        }
        return this.redraw();
      },
      draw: function(action) {}
    };
    return $.sketch.tools.eraser = {
      onEvent: function(e) {
        return $.sketch.tools.marker.onEvent.call(this, e);
      },
      draw: function(action) {
        var oldcomposite;
        oldcomposite = this.context.globalCompositeOperation;
        this.context.globalCompositeOperation = "destination-out";
        action.color = "rgba(0,0,0,1)";
        $.sketch.tools.marker.draw.call(this, action);
        return this.context.globalCompositeOperation = oldcomposite;
      }
    };
  })(jQuery);

}).call(this);
